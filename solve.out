============================== Prover9 ===============================
Prover9 (64) version 2009-11A, November 2009.
Process 35860 was started by tudor on Miha,
Sun Dec 15 21:17:08 2024
The command was "bin/prover9 -f solve.in".
============================== end of head ===========================

============================== INPUT =================================

% Reading from file solve.in


formulas(assumptions).
mark(1,1,O).
mark(1,2,X).
mark(1,3,X).
mark(2,1,E).
mark(2,2,X).
mark(2,3,X).
mark(3,1,O).
mark(3,2,O).
mark(3,3,O).
mark(1,1,X) & mark(1,2,X) & mark(1,3,X) -> win(X).
mark(2,1,X) & mark(2,2,X) & mark(2,3,X) -> win(X).
mark(3,1,X) & mark(3,2,X) & mark(3,3,X) -> win(X).
mark(1,1,X) & mark(2,1,X) & mark(3,1,X) -> win(X).
mark(1,2,X) & mark(2,2,X) & mark(3,2,X) -> win(X).
mark(1,3,X) & mark(2,3,X) & mark(3,3,X) -> win(X).
mark(1,1,X) & mark(2,2,X) & mark(3,3,X) -> win(X).
mark(1,3,X) & mark(2,2,X) & mark(3,1,X) -> win(X).
mark(1,1,O) & mark(1,2,O) & mark(1,3,O) -> win(O).
mark(2,1,O) & mark(2,2,O) & mark(2,3,O) -> win(O).
mark(3,1,O) & mark(3,2,O) & mark(3,3,O) -> win(O).
mark(1,1,O) & mark(2,1,O) & mark(3,1,O) -> win(O).
mark(1,2,O) & mark(2,2,O) & mark(3,2,O) -> win(O).
mark(1,3,O) & mark(2,3,O) & mark(3,3,O) -> win(O).
mark(1,1,O) & mark(2,2,O) & mark(3,3,O) -> win(O).
mark(1,3,O) & mark(2,2,O) & mark(3,1,O) -> win(O).
end_of_list.

formulas(goals).
win(O).
end_of_list.

============================== end of input ==========================

============================== PROCESS NON-CLAUSAL FORMULAS ==========

% Formulas that are not ordinary clauses:
1 mark(1,1,X) & mark(1,2,X) & mark(1,3,X) -> win(X) # label(non_clause).  [assumption].
2 mark(2,1,X) & mark(2,2,X) & mark(2,3,X) -> win(X) # label(non_clause).  [assumption].
3 mark(3,1,X) & mark(3,2,X) & mark(3,3,X) -> win(X) # label(non_clause).  [assumption].
4 mark(1,1,X) & mark(2,1,X) & mark(3,1,X) -> win(X) # label(non_clause).  [assumption].
5 mark(1,2,X) & mark(2,2,X) & mark(3,2,X) -> win(X) # label(non_clause).  [assumption].
6 mark(1,3,X) & mark(2,3,X) & mark(3,3,X) -> win(X) # label(non_clause).  [assumption].
7 mark(1,1,X) & mark(2,2,X) & mark(3,3,X) -> win(X) # label(non_clause).  [assumption].
8 mark(1,3,X) & mark(2,2,X) & mark(3,1,X) -> win(X) # label(non_clause).  [assumption].
9 mark(1,1,O) & mark(1,2,O) & mark(1,3,O) -> win(O) # label(non_clause).  [assumption].
10 mark(2,1,O) & mark(2,2,O) & mark(2,3,O) -> win(O) # label(non_clause).  [assumption].
11 mark(3,1,O) & mark(3,2,O) & mark(3,3,O) -> win(O) # label(non_clause).  [assumption].
12 mark(1,1,O) & mark(2,1,O) & mark(3,1,O) -> win(O) # label(non_clause).  [assumption].
13 mark(1,2,O) & mark(2,2,O) & mark(3,2,O) -> win(O) # label(non_clause).  [assumption].
14 mark(1,3,O) & mark(2,3,O) & mark(3,3,O) -> win(O) # label(non_clause).  [assumption].
15 mark(1,1,O) & mark(2,2,O) & mark(3,3,O) -> win(O) # label(non_clause).  [assumption].
16 mark(1,3,O) & mark(2,2,O) & mark(3,1,O) -> win(O) # label(non_clause).  [assumption].
17 win(O) # label(non_clause) # label(goal).  [goal].

============================== end of process non-clausal formulas ===

============================== PROCESS INITIAL CLAUSES ===============

% Clauses before input processing:

formulas(usable).
end_of_list.

formulas(sos).
mark(1,1,O).  [assumption].
mark(1,2,X).  [assumption].
mark(1,3,X).  [assumption].
mark(2,1,E).  [assumption].
mark(2,2,X).  [assumption].
mark(2,3,X).  [assumption].
mark(3,1,O).  [assumption].
mark(3,2,O).  [assumption].
mark(3,3,O).  [assumption].
-mark(1,1,X) | -mark(1,2,X) | -mark(1,3,X) | win(X).  [clausify(1)].
-mark(2,1,X) | -mark(2,2,X) | -mark(2,3,X) | win(X).  [clausify(2)].
-mark(3,1,X) | -mark(3,2,X) | -mark(3,3,X) | win(X).  [clausify(3)].
-mark(1,1,X) | -mark(2,1,X) | -mark(3,1,X) | win(X).  [clausify(4)].
-mark(1,2,X) | -mark(2,2,X) | -mark(3,2,X) | win(X).  [clausify(5)].
-mark(1,3,X) | -mark(2,3,X) | -mark(3,3,X) | win(X).  [clausify(6)].
-mark(1,1,X) | -mark(2,2,X) | -mark(3,3,X) | win(X).  [clausify(7)].
-mark(1,3,X) | -mark(2,2,X) | -mark(3,1,X) | win(X).  [clausify(8)].
-mark(1,1,O) | -mark(1,2,O) | -mark(1,3,O) | win(O).  [clausify(9)].
-mark(2,1,O) | -mark(2,2,O) | -mark(2,3,O) | win(O).  [clausify(10)].
-mark(3,1,O) | -mark(3,2,O) | -mark(3,3,O) | win(O).  [clausify(11)].
-mark(1,1,O) | -mark(2,1,O) | -mark(3,1,O) | win(O).  [clausify(12)].
-mark(1,2,O) | -mark(2,2,O) | -mark(3,2,O) | win(O).  [clausify(13)].
-mark(1,3,O) | -mark(2,3,O) | -mark(3,3,O) | win(O).  [clausify(14)].
-mark(1,1,O) | -mark(2,2,O) | -mark(3,3,O) | win(O).  [clausify(15)].
-mark(1,3,O) | -mark(2,2,O) | -mark(3,1,O) | win(O).  [clausify(16)].
-win(O).  [deny(17)].
end_of_list.

formulas(demodulators).
end_of_list.

============================== PREDICATE ELIMINATION =================

Eliminating win/1
18 -win(O).  [deny(17)].
19 -mark(1,1,X) | -mark(1,2,X) | -mark(1,3,X) | win(X).  [clausify(1)].
20 -mark(2,1,X) | -mark(2,2,X) | -mark(2,3,X) | win(X).  [clausify(2)].
21 -mark(3,1,X) | -mark(3,2,X) | -mark(3,3,X) | win(X).  [clausify(3)].
22 -mark(1,1,X) | -mark(2,1,X) | -mark(3,1,X) | win(X).  [clausify(4)].
23 -mark(1,2,X) | -mark(2,2,X) | -mark(3,2,X) | win(X).  [clausify(5)].
24 -mark(1,3,X) | -mark(2,3,X) | -mark(3,3,X) | win(X).  [clausify(6)].
25 -mark(1,1,X) | -mark(2,2,X) | -mark(3,3,X) | win(X).  [clausify(7)].
26 -mark(1,3,X) | -mark(2,2,X) | -mark(3,1,X) | win(X).  [clausify(8)].
27 -mark(1,1,O) | -mark(1,2,O) | -mark(1,3,O) | win(O).  [clausify(9)].
28 -mark(2,1,O) | -mark(2,2,O) | -mark(2,3,O) | win(O).  [clausify(10)].
29 -mark(3,1,O) | -mark(3,2,O) | -mark(3,3,O) | win(O).  [clausify(11)].
30 -mark(1,1,O) | -mark(2,1,O) | -mark(3,1,O) | win(O).  [clausify(12)].
31 -mark(1,2,O) | -mark(2,2,O) | -mark(3,2,O) | win(O).  [clausify(13)].
32 -mark(1,3,O) | -mark(2,3,O) | -mark(3,3,O) | win(O).  [clausify(14)].
33 -mark(1,1,O) | -mark(2,2,O) | -mark(3,3,O) | win(O).  [clausify(15)].
34 -mark(1,3,O) | -mark(2,2,O) | -mark(3,1,O) | win(O).  [clausify(16)].
Derived: -mark(1,1,O) | -mark(1,2,O) | -mark(1,3,O).  [resolve(18,a,27,d)].
Derived: -mark(2,1,O) | -mark(2,2,O) | -mark(2,3,O).  [resolve(18,a,28,d)].
Derived: -mark(3,1,O) | -mark(3,2,O) | -mark(3,3,O).  [resolve(18,a,29,d)].
Derived: -mark(1,1,O) | -mark(2,1,O) | -mark(3,1,O).  [resolve(18,a,30,d)].
Derived: -mark(1,2,O) | -mark(2,2,O) | -mark(3,2,O).  [resolve(18,a,31,d)].
Derived: -mark(1,3,O) | -mark(2,3,O) | -mark(3,3,O).  [resolve(18,a,32,d)].
Derived: -mark(1,1,O) | -mark(2,2,O) | -mark(3,3,O).  [resolve(18,a,33,d)].
Derived: -mark(1,3,O) | -mark(2,2,O) | -mark(3,1,O).  [resolve(18,a,34,d)].

============================== end predicate elimination =============

Auto_denials:
  % assign(max_proofs, 8).  % (Horn set with more than one neg. clause)

WARNING, because some of the denials share constants,
some of the denials or their descendents may be subsumed,
preventing the target number of proofs from being found.
The shared constants are:  2, O, 3, 1.

Term ordering decisions:
Predicate symbol precedence:  predicate_order([ mark ]).
Function symbol precedence:  function_order([ 1, 2, 3, O, X, E ]).
After inverse_order:  (no changes).
Unfolding symbols: (none).

Auto_inference settings:
  % set(neg_binary_resolution).  % (HNE depth_diff=0)
  % clear(ordered_res).  % (HNE depth_diff=0)
  % set(ur_resolution).  % (HNE depth_diff=0)
    % set(ur_resolution) -> set(pos_ur_resolution).
    % set(ur_resolution) -> set(neg_ur_resolution).

Auto_process settings:
  % set(unit_deletion).  % (Horn set with negative nonunits)

kept:      35 mark(1,1,O).  [assumption].
kept:      36 mark(1,2,X).  [assumption].
kept:      37 mark(1,3,X).  [assumption].
kept:      38 mark(2,1,E).  [assumption].
kept:      39 mark(2,2,X).  [assumption].
kept:      40 mark(2,3,X).  [assumption].
kept:      41 mark(3,1,O).  [assumption].
kept:      42 mark(3,2,O).  [assumption].
kept:      43 mark(3,3,O).  [assumption].
           44 -mark(1,1,O) | -mark(1,2,O) | -mark(1,3,O).  [resolve(18,a,27,d)].
kept:      45 -mark(1,2,O) | -mark(1,3,O).  [copy(44),unit_del(a,35)].
kept:      46 -mark(2,1,O) | -mark(2,2,O) | -mark(2,3,O).  [resolve(18,a,28,d)].
           47 -mark(3,1,O) | -mark(3,2,O) | -mark(3,3,O).  [resolve(18,a,29,d)].

============================== PROOF =================================

% Proof 1 at 0.00 (+ 0.01) seconds.
% Length of proof is 9.
% Level of proof is 3.
% Maximum clause weight is 4.000.
% Given clauses 0.

11 mark(3,1,O) & mark(3,2,O) & mark(3,3,O) -> win(O) # label(non_clause).  [assumption].
17 win(O) # label(non_clause) # label(goal).  [goal].
18 -win(O).  [deny(17)].
29 -mark(3,1,O) | -mark(3,2,O) | -mark(3,3,O) | win(O).  [clausify(11)].
41 mark(3,1,O).  [assumption].
42 mark(3,2,O).  [assumption].
43 mark(3,3,O).  [assumption].
47 -mark(3,1,O) | -mark(3,2,O) | -mark(3,3,O).  [resolve(18,a,29,d)].
48 $F.  [copy(47),unit_del(a,41),unit_del(b,42),unit_del(c,43)].

============================== end of proof ==========================
           49 -mark(1,1,O) | -mark(2,1,O) | -mark(3,1,O).  [resolve(18,a,30,d)].
kept:      50 -mark(2,1,O).  [copy(49),unit_del(a,35),unit_del(c,41)].
           51 -mark(1,2,O) | -mark(2,2,O) | -mark(3,2,O).  [resolve(18,a,31,d)].
kept:      52 -mark(1,2,O) | -mark(2,2,O).  [copy(51),unit_del(c,42)].
           53 -mark(1,3,O) | -mark(2,3,O) | -mark(3,3,O).  [resolve(18,a,32,d)].
kept:      54 -mark(1,3,O) | -mark(2,3,O).  [copy(53),unit_del(c,43)].
           55 -mark(1,1,O) | -mark(2,2,O) | -mark(3,3,O).  [resolve(18,a,33,d)].
kept:      56 -mark(2,2,O).  [copy(55),unit_del(a,35),unit_del(c,43)].
           57 -mark(1,3,O) | -mark(2,2,O) | -mark(3,1,O).  [resolve(18,a,34,d)].

% Disable descendants (x means already disabled):
 0x 18x 44x 45 46x 47x 49x 50 51x 52x
 53x 54 55x 56 57x

============================== end of process initial clauses ========

============================== CLAUSES FOR SEARCH ====================

% Clauses after input processing:

formulas(usable).
end_of_list.

formulas(sos).
35 mark(1,1,O).  [assumption].
36 mark(1,2,X).  [assumption].
37 mark(1,3,X).  [assumption].
38 mark(2,1,E).  [assumption].
39 mark(2,2,X).  [assumption].
40 mark(2,3,X).  [assumption].
41 mark(3,1,O).  [assumption].
42 mark(3,2,O).  [assumption].
43 mark(3,3,O).  [assumption].
end_of_list.

formulas(demodulators).
end_of_list.

============================== end of clauses for search =============

============================== SEARCH ================================

% Starting search at 0.01 seconds.

given #1 (I,wt=4): 35 mark(1,1,O).  [assumption].

given #2 (I,wt=4): 36 mark(1,2,X).  [assumption].

given #3 (I,wt=4): 37 mark(1,3,X).  [assumption].

given #4 (I,wt=4): 38 mark(2,1,E).  [assumption].

given #5 (I,wt=4): 39 mark(2,2,X).  [assumption].

given #6 (I,wt=4): 40 mark(2,3,X).  [assumption].

given #7 (I,wt=4): 41 mark(3,1,O).  [assumption].

given #8 (I,wt=4): 42 mark(3,2,O).  [assumption].

given #9 (I,wt=4): 43 mark(3,3,O).  [assumption].

============================== STATISTICS ============================

Given=9. Generated=17. Kept=15. proofs=1.
Usable=9. Sos=0. Demods=0. Limbo=0, Disabled=40. Hints=0.
Kept_by_rule=0, Deleted_by_rule=0.
Forward_subsumed=1. Back_subsumed=2.
Sos_limit_deleted=0. Sos_displaced=0. Sos_removed=0.
New_demodulators=0 (0 lex), Back_demodulated=0. Back_unit_deleted=0.
Demod_attempts=0. Demod_rewrites=0.
Res_instance_prunes=0. Para_instance_prunes=0. Basic_paramod_prunes=0.
Nonunit_fsub_feature_tests=0. Nonunit_bsub_feature_tests=9.
Megabytes=0.09.
User_CPU=0.01, System_CPU=0.01, Wall_clock=0.

============================== end of statistics =====================

============================== end of search =========================

SEARCH FAILED

Exiting with 1 proof.

Process 35860 exit (sos_empty) Sun Dec 15 21:17:08 2024
